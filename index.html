<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="wOowVdE8t-4f7XcFLx9Qgt5xpiWSkjeECVhSr793gxY">
  <meta name="baidu-site-verification" content="c363640d6f7b6c025567421e08aee915">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.prototyped.cn","root":"/","images":"/images","scheme":"Pisces","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="流云的笔记">
<meta property="og:url" content="https://blog.prototyped.cn/index.html">
<meta property="og:site_name" content="流云的笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="流云">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.prototyped.cn/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>流云的笔记</title>
  

  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6538de2a081031fb37bb63527081de39";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">流云的笔记</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录和分享</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">流云</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/cheadaq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cheadaq" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.prototyped.cn/2021/03/30/go-vanity-import/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="流云">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="流云的笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/30/go-vanity-import/" class="post-title-link" itemprop="url">Go Module如何自定义import路径</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-03-30 07:51:15 / 修改时间：22:20:29" itemprop="dateCreated datePublished" datetime="2021-03-30T07:51:15+08:00">2021-03-30</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/03/30/go-vanity-import/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/03/30/go-vanity-import/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>592</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="为什么需要自定义import路径"><a href="#为什么需要自定义import路径" class="headerlink" title="为什么需要自定义import路径"></a>为什么需要自定义import路径</h3><p><a target="_blank" rel="noopener" href="https://golang.google.cn/doc/go1.16">Go 1.16</a>已经默认开启Go Module模式</p>
<h3 id="如何实现自定义import路径"><a href="#如何实现自定义import路径" class="headerlink" title="如何实现自定义import路径"></a>如何实现自定义import路径</h3><h4 id="申请自有域名"><a href="#申请自有域名" class="headerlink" title="申请自有域名"></a>申请自有域名</h4><p>首先，需要申请一个自有域名，如<code>devpkg.work</code></p>
<p>则其它项目要引用simplemod的代码，需要这样import</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;devpkg.work&#x2F;simplemod</span><br></pre></td></tr></table></figure>
<p>创建一个module</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go mod init devpkg.work/simplemod</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>


<h4 id="配置静态web服务"><a href="#配置静态web服务" class="headerlink" title="配置静态web服务"></a>配置静态web服务</h4><p>动态web服务始终要购买云服务，借助<a target="_blank" rel="noopener" href="https://pages.github.com/">Github Page</a> 静态网站托管，<br>再配合<a target="_blank" rel="noopener" href="https://www.netlify.com/">netlify</a>提供的<a target="_blank" rel="noopener" href="https://docs.netlify.com/routing/redirects/">重定向</a>功能，可以做一个白嫖版本的go import域名跳转</p>
<p>步骤如下：</p>
<ol>
<li>创建一个github repo</li>
<li>创建一个netlify app，并绑定此github repo</li>
<li>把自有域名绑定到netlify app上</li>
<li>在github repo上提交go import的html，并编写<code>_redirects</code>里的跳转规则</li>
</ol>
<h4 id="使用此module"><a href="#使用此module" class="headerlink" title="使用此module"></a>使用此module</h4><p>初始化一个exmple，并调用simplemod的代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir example &amp;&amp; <span class="built_in">cd</span> example &amp;&amp; go mod init example</span><br><span class="line">go get -u -v devpkg.work/simplemod</span><br></pre></td></tr></table></figure>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a target="_blank" rel="noopener" href="https://sagikazarmark.hu/blog/vanity-import-paths-in-go/">vanity import paths in Go</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.golang.org/package-names">package name</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang-standards/project-layout">goland-standard-project-layout</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.prototyped.cn/2021/03/11/tabular-tool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="流云">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="流云的笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/11/tabular-tool/" class="post-title-link" itemprop="url">如何实现一个导表工具</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-11 08:05:55" itemprop="dateCreated datePublished" datetime="2021-03-11T08:05:55+08:00">2021-03-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-21 11:11:46" itemprop="dateModified" datetime="2021-03-21T11:11:46+08:00">2021-03-21</time>
      </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/03/11/tabular-tool/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/03/11/tabular-tool/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>344</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在游戏开发的过程中，我们的策划同事(Game Designer)通常会把一些游戏系统的配置数据使用excel来进行配置，然后程序同事拿到这个excel表，如果能很快地完成数据结构定义和数据读取，那样会节省很多开发时间，自然而然就产生了导表工具的开发需求。</p>
<p>导表工具做的事情其实很简单，就是<code>导出</code>和<code>生成</code>两个功能，<code>导出</code>是解析excel表格把数据转换为csv、json之类的代码已解析的文件格式，<code>生成</code>是生成程序代码API，业务模块直接调用这个API就可以完成配置数据的读取和解析，甚至筛选。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>假如有下面这样的一个表格</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Damage</th>
<th>Level</th>
<th>CostFood</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>int</td>
<td>int16</td>
<td>int</td>
</tr>
<tr>
<td>名称</td>
<td>每秒伤害</td>
<td>等级</td>
<td>食物消耗</td>
</tr>
<tr>
<td>Marine</td>
<td>100</td>
<td>1</td>
<td>100</td>
</tr>
<tr>
<td>Marine</td>
<td>150</td>
<td>2</td>
<td>200</td>
</tr>
<tr>
<td>Marine</td>
<td>200</td>
<td>3</td>
<td>500</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blog.prototyped.cn/2021/03/06/protobuf-in-game/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="流云">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="流云的笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/06/protobuf-in-game/" class="post-title-link" itemprop="url">protobuf在游戏通信协议中的使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-06 07:57:55" itemprop="dateCreated datePublished" datetime="2021-03-06T07:57:55+08:00">2021-03-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-30 22:02:44" itemprop="dateModified" datetime="2021-03-30T22:02:44+08:00">2021-03-30</time>
      </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/03/06/protobuf-in-game/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/03/06/protobuf-in-game/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="通协议中的消息"><a href="#通协议中的消息" class="headerlink" title="通协议中的消息"></a>通协议中的消息</h3><p>对游戏项目而言，我们通常会使用TCP进行前后端的通信协议开发，TCP是字节流协议，所以还需要在网络代码里把TCP字节流解析成应用层需要的一条一条消息(message)。</p>
<p>一条消息包含消息ID和消息内容(payload)。</p>
<p>消息ID主要用于告知业务代码后续的二进制payload应该解析成什么样的结构，通常为了节省流量，消息ID使用整数表示。</p>
<p>以登陆消息为例，如下所示:</p>
<table>
<thead>
<tr>
<th>消息ID</th>
<th>消息payload</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>登录账号、token等</td>
</tr>
<tr>
<td>1002</td>
<td>登录状态、访问token等</td>
</tr>
</tbody></table>
<h3 id="收发消息流程"><a href="#收发消息流程" class="headerlink" title="收发消息流程"></a>收发消息流程</h3><p>在业务层上消息主要有两种类型，一种是请求响应(request/response)，也就是client发送一条消息给server，server也需要相应地回一条消息给client。</p>
<p>另一种是通知，通知消息不需要对方回复响应，client和server都可以给对方发送通知。</p>
<p>server和client的收消息流程是：</p>
<ul>
<li>读取消息字节流，先根据固定长度（比如4字节）解码出消息大小（包括消息ID和消息payload)；</li>
<li>读取消息ID后根据ID内容，new一个编程语言里的对应的结构，把消息payload解码到结构里；</li>
<li>把消息结构传递给后续业务代码处理；</li>
</ul>
<p>server和client的发消息流程是:</p>
<ul>
<li>业务代码new一个编程语言的消息结构，设置好结构中每个成员的值；</li>
<li>把此消息结构和其对应消息ID编码为字节流；</li>
<li>投递给网络层发送；</li>
</ul>
<h3 id="自定义消息编解码"><a href="#自定义消息编解码" class="headerlink" title="自定义消息编解码"></a>自定义消息编解码</h3><p>以C++语言为例，来看一个简单的不使用常用序列化格式(json, msgpack, protobuf)的通信协议编解码实现，为了聚焦于编解码的内容，下面的代码都不涉及具体的网络层实现。</p>
<p>首先，我们把消息ID用枚举实现，把消息结构用struct定义出来，如下代码所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// protocol.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息ID枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MessageID</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    MSG_DISCONNECT_NOTIFY = <span class="number">1000</span>,   <span class="comment">// 下线通知</span></span><br><span class="line">    MSG_LOGIN_REQUEST = <span class="number">1001</span>,       <span class="comment">// 登录请求</span></span><br><span class="line">    MSG_LOGIN_REPLY = <span class="number">1002</span>,         <span class="comment">// 登录响应</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下线通知</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DisconnectNotify</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> err_code;   <span class="comment">// 错误码</span></span><br><span class="line">    <span class="built_in">string</span> reason;      <span class="comment">// 原因(重复登录或者被踢下线)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录请求</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LoginReq</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> user;            <span class="comment">// 账号</span></span><br><span class="line">    <span class="built_in">string</span> token;           <span class="comment">// 令牌</span></span><br><span class="line">    <span class="keyword">int64_t</span> unix_time;      <span class="comment">// 时间戳</span></span><br><span class="line">    <span class="built_in">string</span> lang;            <span class="comment">// 区域和语言</span></span><br><span class="line">    <span class="built_in">string</span> client_os;       <span class="comment">// iOS, Android, Web</span></span><br><span class="line">    <span class="built_in">string</span> app_version;     <span class="comment">// 客户端版本</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录响应</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LoginAck</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> err_code;       <span class="comment">// 错误码</span></span><br><span class="line">    <span class="built_in">string</span> access_token;    <span class="comment">// 访问令牌</span></span><br><span class="line">    <span class="keyword">int32_t</span> session;        <span class="comment">// 会话</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我在以上代码中定义了3个消息ID和与其对应的3个消息结构，在发送的时候需要给每个消息结构的成员赋值，然后按一些约定的序列化方法把消息结构编码到字节流，整数是直接编码内存大小，字符串先编码长度再编码内容（不包括’\0’），struct依次编码每个成员，vector和map等容器先编码大小再逐个编码每一个元素。</p>
<p>所以我们再为每个消息结构定义encodeTo/decodeFrom函数来实现编解码，如下代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// protocol.cpp</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; Buffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码LoginReq到buffer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LoginReq::encodeTo</span><span class="params">(Buffer&amp; buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    encodeString(<span class="keyword">this</span>-&gt;user, buf);</span><br><span class="line">    encodeString(<span class="keyword">this</span>-&gt;token, buf);</span><br><span class="line">    encodeNumber(<span class="keyword">this</span>-&gt;unix_time, buf);</span><br><span class="line">    encodeString(<span class="keyword">this</span>-&gt;lang, buf);</span><br><span class="line">    encodeString(<span class="keyword">this</span>-&gt;client_os, buf);</span><br><span class="line">    encodeString(<span class="keyword">this</span>-&gt;app_version, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从buffer中解码LoginReq</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LoginReq::decodeFrom</span><span class="params">(Buffer&amp; buf, <span class="keyword">int</span>&amp; pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    decodeString(<span class="keyword">this</span>-&gt;user, buf, pos);</span><br><span class="line">    decodeString(<span class="keyword">this</span>-&gt;token, buf, pos);</span><br><span class="line">    decodeNumber(&amp;<span class="keyword">this</span>-&gt;unix_time, buf, pos);</span><br><span class="line">    decodeString(<span class="keyword">this</span>-&gt;lang, buf, pos);</span><br><span class="line">    decodeString(<span class="keyword">this</span>-&gt;client_os, buf, pos);</span><br><span class="line">    decodeString(<span class="keyword">this</span>-&gt;app_version, buf, pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的简版序列化方式在业务层的使用示例大致如下面的代码所示，完整的示例见<a target="_blank" rel="noopener" href="https://github.com/slimccq/examples/tree/main/protobuf/pure-cpp">github</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LoginReq req;</span><br><span class="line">    req.user = <span class="string">&quot;user001&quot;</span>;</span><br><span class="line">    req.token = <span class="string">&quot;pnyuza0h2cdkvxvh54v3dn&quot;</span>;</span><br><span class="line">    req.unix_timestamp = <span class="number">1615004452</span>;</span><br><span class="line">    req.lang = <span class="string">&quot;zh-CN&quot;</span>;</span><br><span class="line">    req.client_os = <span class="string">&quot;Windows 10&quot;</span>;</span><br><span class="line">    req.app_version = <span class="string">&quot;1.0.1&quot;</span>;</span><br><span class="line">    printLoginReq(req); <span class="comment">// 打印每个成员</span></span><br><span class="line"></span><br><span class="line">    Buffer buf;</span><br><span class="line">    req.encodeTo(buf); <span class="comment">// 编码到buffer</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 把buffer发送到网络</span></span><br><span class="line"></span><br><span class="line">    LoginReq req2;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    req2.decodeFrom(buf, pos); <span class="comment">// 从buffer中解码</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;after decode:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    printLoginReq(req2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码有几个细节，比如：</p>
<ol>
<li>如何方便的添加和删除字段，并保证前向版本的兼容性；</li>
<li>如何支持其他编程语言方便地反序列化；</li>
</ol>
<p>对问题1，自定义协议的编解码不支持更改数据类型和增删某些字段。</p>
<p>对问题2，C++的二进制怎么编码，其他语言就得怎么解码，类似python之类的动态语言需要使用二进制解析库。</p>
<p>虽然自定义协议编解码的方案大多都没有完全解决这些问题，但是这种协议的确是早些年很多项目广泛使用的方式。<br>甚至现在还有很多C#,Go语言项目也会选择这种自定义协议的方式，只是有了反射的支持，跟传统的C++相比会多一点灵活性。</p>
<h3 id="使用protobuf"><a href="#使用protobuf" class="headerlink" title="使用protobuf"></a>使用protobuf</h3><p><a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/">protobuf</a>是一种序列化结构化数据的形式，protobuf的基本概念和编码格式参考google官方文档，这里不再赘述。</p>
<h4 id="手动解析消息ID和消息结构"><a href="#手动解析消息ID和消息结构" class="headerlink" title="手动解析消息ID和消息结构"></a>手动解析消息ID和消息结构</h4><p>下面还是以C++语言为例，展示一下如何使用protobuf实现上文的登录协议，然后分析一下和自定义协议相比的优势。</p>
<p>protobuf要求我们事先按照它的语法把协议定义在proto文件中，然后再使用它的编译器(<a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf/releases/download/v3.15.5/protoc-3.15.5-win64.zip">protoc</a>)把proto文件编译成对应的编程语言代码，在C++里就是pb.cc文件，protoc会在pb.cc里生成每一个消息结构的字段getter/setter和编解码方法，方便我们直接使用。</p>
<p>protobuf有一套自己的基本数据类型的二进制编码规范，以及一个保证前后版本兼容的编解码方案，proto文件除了是定义DSL语法以外，它还很方便多语言之间的通信协作。</p>
<p>先把消息定义在如下message.proto里</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// message.proto</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 使用protobuf3语法</span></span><br><span class="line"><span class="keyword">package</span> protocol; <span class="comment">// 命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息ID枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MessageID</span> </span>&#123;</span><br><span class="line">    MSG_NONE = <span class="number">0</span>;</span><br><span class="line">    MSG_DISCONNECT_NOTIFY = <span class="number">1000</span>;   <span class="comment">// 下线通知</span></span><br><span class="line">    MSG_LOGIN_REQUEST = <span class="number">1001</span>;       <span class="comment">// 登录请求</span></span><br><span class="line">    MSG_LOGIN_REPLY = <span class="number">1002</span>;         <span class="comment">// 登录响应</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下线通知</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">DisconnectNotify</span> </span>&#123;</span><br><span class="line">    <span class="built_in">int32</span> err_code = <span class="number">1</span>;     <span class="comment">// 错误码</span></span><br><span class="line">    <span class="built_in">string</span> reason = <span class="number">2</span>;      <span class="comment">// 原因(重复登录或者被踢下线)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录请求</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">LoginReq</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> user = <span class="number">1</span>;          <span class="comment">// 账号</span></span><br><span class="line">  <span class="built_in">string</span> token = <span class="number">2</span>;         <span class="comment">// 令牌</span></span><br><span class="line">  <span class="built_in">int64</span> timestamp = <span class="number">3</span>;      <span class="comment">// 时间戳</span></span><br><span class="line">  <span class="built_in">string</span> language = <span class="number">4</span>;      <span class="comment">// 区域和语言</span></span><br><span class="line">  <span class="built_in">string</span> client_os = <span class="number">5</span>;     <span class="comment">// iOS, Android, Web</span></span><br><span class="line">  <span class="built_in">string</span> device_type = <span class="number">6</span>;   <span class="comment">// Windows, Android, iOS</span></span><br><span class="line">  <span class="built_in">string</span> app_version = <span class="number">7</span>;   <span class="comment">// 客户端版本号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">LoginAck</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> err_code = <span class="number">1</span>;       <span class="comment">// 错误码</span></span><br><span class="line">  <span class="built_in">string</span> access_token = <span class="number">2</span>;  <span class="comment">// 访问令牌</span></span><br><span class="line">  <span class="built_in">int32</span> session = <span class="number">3</span>;        <span class="comment">// 会话</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用protoc把proto文件编译成C++代码</p>
<p><code>protoc --cpp_out=. message.proto</code></p>
<p>下一步就是如何解析protobuf消息，假定我们的网络代码会返回一个包含消息ID和二进制字节流的buffer，业务层根据消息ID把字节流反序列化为具体的protobuf消息结构。</p>
<p>第一步我们从一个switch/case开始，把消息ID和消息结构的对应关系写在源码里，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析消息结构</span></span><br><span class="line"><span class="function">Message* <span class="title">parseMessageV1</span><span class="params">(MessageID msgid, Buffer&amp; buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Message* msg = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">switch</span> (msgid)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> MSG_DISCONNECT_NOTIFY:</span><br><span class="line">        msg = <span class="keyword">new</span> DisconnectNotify(); <span class="comment">// 如果消息ID是1000，则创建DisconnectNotify对象</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MSG_LOGIN_REQUEST:</span><br><span class="line">        msg = <span class="keyword">new</span> LoginReq(); <span class="comment">// 如果消息ID是1001，则创建LoginReq对象</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MSG_LOGIN_REPLY:</span><br><span class="line">        msg = <span class="keyword">new</span> LoginAck(); <span class="comment">// 如果消息ID是1002，则创建LoginAck对象</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用protobuf提供ParseFromArray方法解码消息</span></span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;ParseFromArray(buf.data(), (<span class="keyword">int</span>)buf.size()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> msg;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码逻辑非常简单明了，根据消息ID创建消息对象，然后把指针赋给基类Message*，再解析后续字节流。只是带来了一个明显的缺点就是，随着后面协议的增加，这个switch/case会变得非常冗长。</p>
<p>这个问题在于如何把消息ID和消息结构方便地关联起来，switch/case只是一种关联形式，当拿到一个消息ID地时候可以很自然地用对应地消息结构进行下一步解析，在语言级别我们可以利用一点C++的宏技巧把消息ID和消息结构映射起来，把解码消息的操作通用化，如下代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用宏映射消息ID和消息名称</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GEN_MESSAGE_MAP(XX) \</span></span><br><span class="line">	XX(MSG_DISCONNECT_NOTIFY, DisconnectNotify) \</span><br><span class="line">	XX(MSG_LOGIN_REQUEST, LoginReq) \</span><br><span class="line">	XX(MSG_LOGIN_REPLY, LoginAck) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据消息ID创建一个具体的消息对象</span></span><br><span class="line"><span class="comment">// 因为protobuf所有的message都会继承自protobuf::Message基类，所以可以返回基类指针</span></span><br><span class="line"><span class="function">Message* <span class="title">createMessageBy</span><span class="params">(MessageID msgid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这个switch/case经过宏展开以后跟上面的switch/case其实是一样的</span></span><br><span class="line">    <span class="keyword">switch</span> (msgid)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XX(msgid, msgname) case msgid: return new msgname;</span></span><br><span class="line">        GEN_MESSAGE_MAP(XX)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> XX</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析消息结构</span></span><br><span class="line"><span class="function">Message* <span class="title">parseMessageV2</span><span class="params">(MessageID msgid, Buffer&amp; buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> msg = createMessageBy(msgid);</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;ParseFromArray(buf.data(), (<span class="keyword">int</span>)buf.size()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的示例见<a target="_blank" rel="noopener" href="https://github.com/slimccq/examples/tree/main/protobuf/protobuf-manual">github</a></p>
<p><code>createMessageBy</code>经过宏展开后就跟<code>parseMessageV2</code>中的switch/case一致了，修改协议的时候只需要修改宏定义。</p>
<p>到这里其实代码已经简化了很多了，但是我们每次增加修改删除协议，除了修改message.proto，还需要修改这个C++宏，也就是源码层面要做两次修改，而且要保持一致性，有没有办法只修改一次，也就是只用修改message.proto，代码就能自动识别？</p>
<p>答案是有的，需要用到protobuf的反射支持。</p>
<h4 id="使用protobuf的反射支持"><a href="#使用protobuf的反射支持" class="headerlink" title="使用protobuf的反射支持"></a>使用protobuf的反射支持</h4><p>protobuf的反射使用Descriptor对象来表示，proto文件有FileDescriptor，消息有MessageDescriptor，消息的字段有FieldDescriptor。用Descriptor对象我们能读取到所有消息结构的定义信息，包括类型、名称、包含字段等等。</p>
<p>上面有提到，这个代码简化的核心其实是如何把消息ID和消息结构关联起来，上述代码是通过在代码里手写switch/case来实现，现在有了反射，protobuf支持通过消息名字查询到Descriptor对象，并可以通过Descriptor对象创建消息结构对象，那我们要做的就是把消息ID和消息名字关联起来。</p>
<p>一个很自然的想法就是通过字符串hash(比如crc32/fnv)，消息ID就是消息名称的hash值，在程序的启动阶段，遍历所有消息对象拿到所有消息的名称，把消息名称的hash和对应的Descriptor对象关联起来，比如放到字典中。</p>
<p>这样从网络层读取到消息ID（也就是消息名字hash)的时候，用这个hash去关联字典查找到Descriptor对象，再通过Descriptor对象生成消息结构，有了消息结构就可以做消息解析了。</p>
<p>大致实现代码如下，完整的示例见<a target="_blank" rel="noopener" href="https://github.com/slimccq/examples/tree/main/protobuf/protobuf-reflection">github</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息名称hash和消息descriptor的映射</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">uint32_t</span>, <span class="keyword">const</span> Descriptor*&gt; registry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化关联字典</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initProtoRegistryV1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> DescriptorPool* pool = DescriptorPool::generated_pool();</span><br><span class="line">    DescriptorDatabase* db = pool-&gt;internal_generated_database();</span><br><span class="line">    <span class="keyword">if</span> (db == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; file_names;</span><br><span class="line">    db-&gt;FindAllFileNames(&amp;file_names);   <span class="comment">// 遍历得到所有proto文件名</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename : file_names)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> FileDescriptor* fileDescriptor = DescriptorPool::generated_pool()-&gt;FindFileByName(filename);</span><br><span class="line">        <span class="keyword">if</span> (fileDescriptor == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> msgcount = fileDescriptor-&gt;message_type_count();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; msgcount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> Descriptor* descriptor = fileDescriptor-&gt;message_type(i);</span><br><span class="line">            <span class="keyword">if</span> (descriptor != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name = descriptor-&gt;full_name();</span><br><span class="line">                <span class="keyword">if</span> (startsWith(name, <span class="string">&quot;protocol&quot;</span>)) <span class="comment">// 指定命名空间</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 约定消息名称中：Req结尾代表请求， Ack结尾代表响应，Ntf结尾代表通知</span></span><br><span class="line">                    <span class="comment">// 则含有指定后缀的消息才会自动加入关联</span></span><br><span class="line">                    <span class="keyword">if</span> (hasSuffix(name)) &#123;</span><br><span class="line">                        <span class="keyword">uint32_t</span> hash = fnvHash(name);</span><br><span class="line">                        registry[hash] = descriptor;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过hash找到descriptor指针，再用descriptor指针创建具体的消息对象</span></span><br><span class="line">google::<span class="function">protobuf::Message* <span class="title">createMessage</span><span class="params">(<span class="keyword">uint32_t</span> hash)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> iter = registry.find(hash);</span><br><span class="line">    <span class="keyword">if</span> (iter == registry.end()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> Message* protoType = MessageFactory::generated_factory()-&gt;GetPrototype(iter-&gt;second);</span><br><span class="line">    <span class="keyword">if</span> (protoType != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> protoType-&gt;New();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在程序启动阶段调用<code>initProtoRegistry()</code>初始化所有消息ID和消息结构关联的字典，当从网络层读取到消息ID和消息<br>结构字节流的时候，把消息ID作为参数调用<code>createMessage()</code>返回消息结构对象，然后再使用protobuf内置的<code>ParseFromArray()</code>方法解析消息字节流到消息结构中。</p>
<p>到此，整个通信协议的开发流程已经非常简化了，大部分项目能做到这一步也已经是很不错了。</p>
<p>对于上面的方案，主要是有几个不尽人意的地方：</p>
<ol>
<li>消息名称不能随便修改，因为改动了消息ID(也就是名称的hash)就会变化，会影响到兼容性；</li>
<li>消息ID不能指定范围，比如我做了一个系统，希望接受的消息ID在范围1000-10000之间，不在此区间的就直接丢弃；</li>
<li>在调试的时候，收到一个消息ID，它通常很大，我们很难在肉眼层面去debug它是不是一个合理的消息ID值；</li>
</ol>
<p>所以还有第二个选择，使用protobuf的MessageOption。</p>
<p>我们在定义proto文件的时候，还是使用枚举作为消息ID，这样我们可以控制消息ID的范围，然后我们再使用MessageOption手动给每个Message对象指定消息ID，在注册消息ID的关联字典的时候，把MessageOption里指定的消息ID与消息Descriptor关联，其它都与上面的使用消息名称的hash方式一致。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/descriptor.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义消息ID的option</span></span><br><span class="line">extend google.protobuf.MessageOptions &#123; MessageID MsgID = <span class="number">50002</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息ID枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MessageID</span> </span>&#123;</span><br><span class="line">    MSG_NONE = <span class="number">0</span>;</span><br><span class="line">    MSG_DISCONNECT_NOTIFY = <span class="number">1000</span>;</span><br><span class="line">    MSG_LOGIN_REQUEST = <span class="number">1001</span>;</span><br><span class="line">    MSG_LOGIN_REPLY = <span class="number">1002</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下线通知</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">DisconnectNtf</span> </span>&#123;</span><br><span class="line">    <span class="keyword">option</span> (MsgID) = MSG_DISCONNECT_NOTIFY;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int32</span> err_code = <span class="number">1</span>;     <span class="comment">// 错误码</span></span><br><span class="line">    <span class="built_in">string</span> reason = <span class="number">2</span>;      <span class="comment">// 原因(重复登录或者被踢下线)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录请求</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">LoginReq</span> </span>&#123;</span><br><span class="line">  <span class="keyword">option</span> (MsgID) = MSG_LOGIN_REQUEST;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">string</span> user = <span class="number">1</span>;          <span class="comment">// 账号</span></span><br><span class="line">  <span class="built_in">string</span> token = <span class="number">2</span>;         <span class="comment">// 令牌</span></span><br><span class="line">  <span class="built_in">int64</span> unix_time = <span class="number">3</span>;      <span class="comment">// 时间戳</span></span><br><span class="line">  <span class="built_in">string</span> language = <span class="number">4</span>;      <span class="comment">// 区域和语言</span></span><br><span class="line">  <span class="built_in">string</span> client_os = <span class="number">5</span>;     <span class="comment">// iOS, Android, Web</span></span><br><span class="line">  <span class="built_in">string</span> device_type = <span class="number">6</span>;   <span class="comment">// Windows, Android, iOS</span></span><br><span class="line">  <span class="built_in">string</span> app_version = <span class="number">7</span>;   <span class="comment">// 客户端版本号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录返回</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">LoginAck</span> </span>&#123;</span><br><span class="line">  <span class="keyword">option</span> (MsgID) = MSG_LOGIN_REPLY;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">int32</span> err_code = <span class="number">1</span>;       <span class="comment">// 错误码</span></span><br><span class="line">  <span class="built_in">string</span> access_token = <span class="number">2</span>;  <span class="comment">// 访问令牌</span></span><br><span class="line">  <span class="built_in">int32</span> session = <span class="number">3</span>;        <span class="comment">// 会话</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册消息的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册消息ID关联字典</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initProtoRegistryV2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> DescriptorPool* pool = DescriptorPool::generated_pool();</span><br><span class="line">    DescriptorDatabase* db = pool-&gt;internal_generated_database();</span><br><span class="line">    <span class="keyword">if</span> (db == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; file_names;</span><br><span class="line">    db-&gt;FindAllFileNames(&amp;file_names);   <span class="comment">// 遍历得到所有proto文件名</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename : file_names)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> FileDescriptor* fileDescriptor = pool-&gt;FindFileByName(filename);</span><br><span class="line">        <span class="keyword">if</span> (fileDescriptor == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> msgcount = fileDescriptor-&gt;message_type_count();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; msgcount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> Descriptor* descriptor = fileDescriptor-&gt;message_type(i);</span><br><span class="line">            <span class="keyword">if</span> (descriptor != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name = descriptor-&gt;full_name();</span><br><span class="line">                <span class="keyword">if</span> (startsWith(name, <span class="string">&quot;protocol&quot;</span>)) &#123; <span class="comment">// 指定命名空间</span></span><br><span class="line">                    <span class="comment">// 约定消息名称中：Req结尾代表请求， Ack结尾代表响应，Ntf结尾代表通知</span></span><br><span class="line">                    <span class="comment">// 则含有指定后缀的消息才会自动加入关联</span></span><br><span class="line">                    <span class="keyword">if</span> (hasSuffix(name)) &#123;</span><br><span class="line">                        <span class="keyword">auto</span> opts = descriptor-&gt;options();</span><br><span class="line">                        protocol::MessageID v = opts.GetExtension(protocol::MsgID);</span><br><span class="line">                        registry[v] = descriptor;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据ID创建消息结构还是一样</span></span><br><span class="line">google::<span class="function">protobuf::Message* <span class="title">createMessageV2</span><span class="params">(protocol::MessageID msgId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> iter = registry2.find(msgId);</span><br><span class="line">    <span class="keyword">if</span> (iter == registry2.end())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> Message* protoType = MessageFactory::generated_factory()-&gt;GetPrototype(iter-&gt;second);</span><br><span class="line">    <span class="keyword">if</span> (protoType != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> protoType-&gt;New();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用MessageOption后序列化代码已经非常简化了，只需要在启动代码里调用<code>initProtoRegistryV2()</code>注册消息ID和消息结构的关联字典即可。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>






<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">流云</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">12k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">11 分钟</span>
  </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://slimccq.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
